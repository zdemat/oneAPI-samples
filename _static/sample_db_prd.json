[{"name":"1D Heat Transfer","description":"The 1D Heat Transfer sample simulates 1D Heat Transfer problem using SYCL","url":"https:\/\/github.com\/oneapi-src\/oneAPI-samples\/tree\/master\/DirectProgramming\/C++SYCL\/StructuredGrids\/1d_HeatTransfer","languages":[{"cpp":{}}],"targetDevice":["CPU","GPU"],"expertise":"Concepts and Functionality","cpuInstructionSets":null,"gpuRequired":null},{"name":"AC Fixed","description":"An Intel\u00ae FPGA tutorial demonstrating how to use the Algorithmic C Fixed Point Data Type (AC Fixed) ","url":"https:\/\/github.com\/oneapi-src\/oneAPI-samples\/tree\/master\/DirectProgramming\/C++SYCL_FPGA\/Tutorials\/Features\/ac_fixed","languages":[{"cpp":{}}],"targetDevice":["FPGA"],"expertise":"Concepts and Functionality","cpuInstructionSets":null,"gpuRequired":null},{"name":"AC Int","description":"An Intel\u00ae FPGA tutorial demonstrating how to use the Algorithmic C Integer (AC Int) ","url":"https:\/\/github.com\/oneapi-src\/oneAPI-samples\/tree\/master\/DirectProgramming\/C++SYCL_FPGA\/Tutorials\/Features\/ac_int","languages":[{"cpp":{}}],"targetDevice":["FPGA"],"expertise":"Concepts and Functionality","cpuInstructionSets":null,"gpuRequired":null},{"name":"Adaptive Noise Reduction","description":"A highly optimized adaptive noise reduction (ANR) algorithm on an FPGA.","url":"https:\/\/github.com\/oneapi-src\/oneAPI-samples\/tree\/master\/DirectProgramming\/C++SYCL_FPGA\/ReferenceDesigns\/anr","languages":[{"cpp":{}}],"targetDevice":["FPGA"],"expertise":"Reference Designs and End to End","cpuInstructionSets":null,"gpuRequired":null},{"name":"All Pairs Shortest Paths","description":"All Pairs Shortest Paths finds the shortest paths between pairs of vertices in a graph using a parallel blocked algorithm that enables the application to efficiently offload compute intensive work to the GPU.","url":"https:\/\/github.com\/oneapi-src\/oneAPI-samples\/tree\/master\/DirectProgramming\/C++SYCL\/GraphAlgorithms\/all-pairs-shortest-paths","languages":[{"cpp":{}}],"targetDevice":["CPU","GPU"],"expertise":"Code Optimization","cpuInstructionSets":null,"gpuRequired":null},{"name":"Autorun kernels","description":"Intel\u00ae FPGA tutorial demonstrating autorun kernels","url":"https:\/\/github.com\/oneapi-src\/oneAPI-samples\/tree\/master\/DirectProgramming\/C++SYCL_FPGA\/Tutorials\/DesignPatterns\/autorun","languages":[{"cpp":{}}],"targetDevice":["FPGA"],"expertise":"Code Optimization","cpuInstructionSets":null,"gpuRequired":null},{"name":"Base: Vector Add","description":"This simple sample adds two large vectors in parallel. Provides a \u2018Hello World!\u2019 like sample to ensure your environment is setup correctly using simple C++ with SYCL","url":"https:\/\/github.com\/oneapi-src\/oneAPI-samples\/tree\/master\/DirectProgramming\/C++SYCL\/DenseLinearAlgebra\/vector-add","languages":[{"cpp":{"properties":{"projectOptions":[{"projectType":"makefile"}]}}}],"targetDevice":["CPU","GPU","FPGA"],"expertise":"Getting Started","cpuInstructionSets":null,"gpuRequired":null},{"name":"Batched Linear Solver","description":"Solve batched linear systems using oneMKL and OpenMP target offloading","url":"https:\/\/github.com\/oneapi-src\/oneAPI-samples\/tree\/master\/Libraries\/oneMKL\/batched_linear_solver","languages":[{"cpp":{"properties":{"projectOptions":[{"projectType":"makefile"}]}}}],"targetDevice":["CPU","GPU"],"expertise":"Code Optimization","cpuInstructionSets":null,"gpuRequired":null},{"name":"Binomial","description":"Binomial European Option Pricing Model Simulation using Intel\u00ae oneMKL Random Number Generators","url":"https:\/\/github.com\/oneapi-src\/oneAPI-samples\/tree\/master\/Libraries\/oneMKL\/binomial","languages":[{"cpp":{"properties":{"projectOptions":[{"projectType":"makefile"}]}}}],"targetDevice":["CPU","GPU"],"expertise":"Concepts and Functionality","cpuInstructionSets":null,"gpuRequired":["gen9"]},{"name":"Bitonic Sort","description":"Bitonic Sort using C++ with SYCL","url":"https:\/\/github.com\/oneapi-src\/oneAPI-samples\/tree\/master\/DirectProgramming\/C++SYCL\/GraphTraversal\/bitonic-sort","languages":[{"cpp":{}}],"targetDevice":["CPU","GPU"],"expertise":"Concepts and Functionality","cpuInstructionSets":null,"gpuRequired":null},{"name":"Black Scholes","description":"Black Scholes formula calculation using Intel\u00ae oneMKL Vector Math and Random Number Generators","url":"https:\/\/github.com\/oneapi-src\/oneAPI-samples\/tree\/master\/Libraries\/oneMKL\/black_scholes","languages":[{"cpp":{"properties":{"projectOptions":[{"projectType":"makefile"}]}}}],"targetDevice":["CPU","GPU"],"expertise":"Concepts and Functionality","cpuInstructionSets":null,"gpuRequired":["gen11"]},{"name":"Block Cholesky Decomposition","description":"Block Cholesky Decomposition using Intel\u00ae oneMKL BLAS and LAPACK","url":"https:\/\/github.com\/oneapi-src\/oneAPI-samples\/tree\/master\/Libraries\/oneMKL\/block_cholesky_decomposition","languages":[{"cpp":{"properties":{"projectOptions":[{"projectType":"makefile"}]}}}],"targetDevice":["CPU","GPU"],"expertise":"Concepts and Functionality","cpuInstructionSets":null,"gpuRequired":null},{"name":"Block LU Decomposition","description":"Block LU Decomposition using Intel\u00ae oneMKL BLAS and LAPACK","url":"https:\/\/github.com\/oneapi-src\/oneAPI-samples\/tree\/master\/Libraries\/oneMKL\/block_lu_decomposition","languages":[{"cpp":{"properties":{"projectOptions":[{"projectType":"makefile"}]}}}],"targetDevice":["CPU","GPU"],"expertise":"Concepts and Functionality","cpuInstructionSets":null,"gpuRequired":null},{"name":"Board Test","description":"An Intel\u00ae FPGA test to check board interfaces and some of the oneAPI shim\/BSP metrics like memory bandwidth, kernel clock frequency and kernel latency","url":"https:\/\/github.com\/oneapi-src\/oneAPI-samples\/tree\/master\/DirectProgramming\/C++SYCL_FPGA\/ReferenceDesigns\/board_test","languages":[{"cpp":{}}],"targetDevice":["FPGA"],"expertise":"Reference Designs and End to End","cpuInstructionSets":null,"gpuRequired":null},{"name":"Buffered Host-Device Streaming","description":"An FPGA tutorial demonstrating how to stream data between the host and device with multiple buffers","url":"https:\/\/github.com\/oneapi-src\/oneAPI-samples\/tree\/master\/DirectProgramming\/C++SYCL_FPGA\/Tutorials\/DesignPatterns\/buffered_host_streaming","languages":[{"cpp":{}}],"targetDevice":["FPGA"],"expertise":"Code Optimization","cpuInstructionSets":null,"gpuRequired":null},{"name":"Census","description":"This sample illustrates the use of Intel\u00ae Distribution of Modin* and Intel Extension for Scikit-learn to build and run an end-to-end machine learning workload","url":"https:\/\/github.com\/oneapi-src\/oneAPI-samples\/tree\/master\/AI-and-Analytics\/End-to-end-Workloads\/Census","languages":[{"python":{}}],"targetDevice":["CPU"],"expertise":"Reference Designs and End to End","cpuInstructionSets":null,"gpuRequired":null},{"name":"Cholesky decomposition","description":"Reference design demonstrating high-performance Cholesky decomposition of real and complex matrices on an Intel\u00ae FPGA","url":"https:\/\/github.com\/oneapi-src\/oneAPI-samples\/tree\/master\/DirectProgramming\/C++SYCL_FPGA\/ReferenceDesigns\/cholesky","languages":[{"cpp":{}}],"targetDevice":["FPGA"],"expertise":"Reference Designs and End to End","cpuInstructionSets":null,"gpuRequired":null},{"name":"Cholesky-based matrix inversion","description":"Reference design demonstrating high-performance Cholesky-based inversion of real and complex matrices on an Intel\u00ae FPGA","url":"https:\/\/github.com\/oneapi-src\/oneAPI-samples\/tree\/master\/DirectProgramming\/C++SYCL_FPGA\/ReferenceDesigns\/cholesky_inversion","languages":[{"cpp":{}}],"targetDevice":["FPGA"],"expertise":"Reference Designs and End to End","cpuInstructionSets":null,"gpuRequired":null},{"name":"Coarray Fortran","description":"Demonstrates how to build and run a serial implementation of a Monte Carlo program, and then convert it to run in parallel using Fortran coarrays.","url":"https:\/\/github.com\/oneapi-src\/oneAPI-samples\/tree\/master\/DirectProgramming\/Fortran\/guided_Coarray","languages":[{"fortran":{}}],"targetDevice":["CPU"],"expertise":"Tutorial","cpuInstructionSets":null,"gpuRequired":null},{"name":"Complex Mult","description":"This sample computes Complex Number Multiplication","url":"https:\/\/github.com\/oneapi-src\/oneAPI-samples\/tree\/master\/DirectProgramming\/C++SYCL\/DenseLinearAlgebra\/complex_mult","languages":[{"cpp":{"properties":{"projectOptions":[{"projectType":"makefile"}]}}}],"targetDevice":["CPU","GPU"],"expertise":"Getting Started","cpuInstructionSets":null,"gpuRequired":null},{"name":"Compute Units","description":"Intel\u00ae FPGA tutorial showcasing a design pattern to enable the creation of compute units","url":"https:\/\/github.com\/oneapi-src\/oneAPI-samples\/tree\/master\/DirectProgramming\/C++SYCL_FPGA\/Tutorials\/DesignPatterns\/compute_units","languages":[{"cpp":{}}],"targetDevice":["FPGA"],"expertise":"Code Optimization","cpuInstructionSets":null,"gpuRequired":null},{"name":"Computed Tomography","description":"Reconstruct an image from simulated CT data with Intel\u00ae oneMKL","url":"https:\/\/github.com\/oneapi-src\/oneAPI-samples\/tree\/master\/Libraries\/oneMKL\/computed_tomography","languages":[{"cpp":{"properties":{"projectOptions":[{"projectType":"makefile"}]}}}],"targetDevice":["CPU","GPU"],"expertise":"Concepts and Functionality","cpuInstructionSets":null,"gpuRequired":["gen11"]},{"name":"convolutionSeparable","description":"This sample implements a separable convolution filter of a 2D signal with a gaussian kernel.","url":"https:\/\/github.com\/oneapi-src\/oneAPI-samples\/tree\/master\/DirectProgramming\/C++SYCL\/guided_convolutionSeparable_SYCLmigration","languages":[{"cpp":{}}],"targetDevice":["CPU","GPU"],"expertise":"Code Optimization","cpuInstructionSets":null,"gpuRequired":null},{"name":"CRR Binomial Tree","description":"This sample shows a Binomial Tree Model for Option Pricing using a FPGA-optimized reference design of the Cox-Ross-Rubinstein (CRR) Binomial Tree Model with Greeks for American exercise options","url":"https:\/\/github.com\/oneapi-src\/oneAPI-samples\/tree\/master\/DirectProgramming\/C++SYCL_FPGA\/ReferenceDesigns\/crr","languages":[{"cpp":{}}],"targetDevice":["FPGA"],"expertise":"Reference Designs and End to End","cpuInstructionSets":null,"gpuRequired":null},{"name":"cuBLAS Migration","description":"This sample shows the execution of cuBLAS function migrated to SYCL.","url":"https:\/\/github.com\/oneapi-src\/oneAPI-samples\/tree\/master\/Libraries\/oneMKL\/guided_cuBLAS_examples_SYCL_Migration","languages":[{"cpp":{}}],"targetDevice":["CPU","GPU"],"expertise":"Code Optimization","cpuInstructionSets":null,"gpuRequired":null},{"name":"CUDA_To_SYCL_Migration","description":"CUDA_To_SYCL_Migration Tutorials using Jupyter Notebooks","url":"https:\/\/github.com\/oneapi-src\/oneAPI-samples\/tree\/master\/DirectProgramming\/C++SYCL\/Jupyter\/cuda-to-sycl-migration-training","languages":[{"cpp":{"properties":{"projectOptions":[{"projectType":"makefile"}]}}}],"targetDevice":["CPU","GPU"],"expertise":"Tutorial","cpuInstructionSets":null,"gpuRequired":["gen11"]},{"name":"cuRAND Migration","description":"This sample shows the execution of cuRAND function migrated to SYCL.","url":"https:\/\/github.com\/oneapi-src\/oneAPI-samples\/tree\/master\/Libraries\/oneMKL\/guided_cuRAND_examples_SYCL_migration","languages":[{"cpp":{}}],"targetDevice":["CPU","GPU"],"expertise":"Code Optimization","cpuInstructionSets":null,"gpuRequired":null},{"name":"DB","description":"An FPGA reference design that demonstrates high-performance Database Query Acceleration on Intel\u00ae FPGAs","url":"https:\/\/github.com\/oneapi-src\/oneAPI-samples\/tree\/master\/DirectProgramming\/C++SYCL_FPGA\/ReferenceDesigns\/db","languages":[{"cpp":{}}],"targetDevice":["FPGA"],"expertise":"Reference Designs and End to End","cpuInstructionSets":null,"gpuRequired":null},{"name":"Debugger: Array Transform","description":"A small SYCL (C++)  example that is used in the \"Get Started Guide\" of the Application Debugger to exercise major debugger functionality","url":"https:\/\/github.com\/oneapi-src\/oneAPI-samples\/tree\/master\/Tools\/ApplicationDebugger\/array-transform","languages":[{"cpp":{}}],"targetDevice":["CPU","GPU"],"expertise":"Getting Started","cpuInstructionSets":null,"gpuRequired":null},{"name":"Decompression","description":"Optimized implementations of GZIP and SNAPPY decompression on an FPGA","url":"https:\/\/github.com\/oneapi-src\/oneAPI-samples\/tree\/master\/DirectProgramming\/C++SYCL_FPGA\/ReferenceDesigns\/decompress","languages":[{"cpp":{}}],"targetDevice":["FPGA"],"expertise":"Reference Designs and End to End","cpuInstructionSets":null,"gpuRequired":null},{"name":"device_global","description":"An Intel\u00ae FPGA tutorial demonstrating the device_global feature","url":"https:\/\/github.com\/oneapi-src\/oneAPI-samples\/tree\/master\/DirectProgramming\/C++SYCL_FPGA\/Tutorials\/Features\/experimental\/device_global","languages":[{"cpp":{}}],"targetDevice":["FPGA"],"expertise":"Concepts and Functionality","cpuInstructionSets":null,"gpuRequired":null},{"name":"Discrete Cosine Transform","description":"An image processing algorithm as seen in the JPEG compression standard","url":"https:\/\/github.com\/oneapi-src\/oneAPI-samples\/tree\/master\/DirectProgramming\/C++SYCL\/SpectralMethods\/DiscreteCosineTransform","languages":[{"cpp":{}}],"targetDevice":["CPU","GPU"],"expertise":"Code Optimization","cpuInstructionSets":null,"gpuRequired":null},{"name":"Double Buffering","description":"Intel\u00ae FPGA tutorial design to demonstrate overlapping kernel execution with buffer transfers and host-processing to improve system performance","url":"https:\/\/github.com\/oneapi-src\/oneAPI-samples\/tree\/master\/DirectProgramming\/C++SYCL_FPGA\/Tutorials\/DesignPatterns\/double_buffering","languages":[{"cpp":{}}],"targetDevice":["FPGA"],"expertise":"Code Optimization","cpuInstructionSets":null,"gpuRequired":null},{"name":"DPC Reduce","description":"This sample models transform Reduce in different ways showing capability of Intel\u00ae oneAPI","url":"https:\/\/github.com\/oneapi-src\/oneAPI-samples\/tree\/master\/DirectProgramming\/C++SYCL\/ParallelPatterns\/dpc_reduce","languages":[{"cpp":{}}],"targetDevice":["CPU","GPU"],"expertise":"Concepts and Functionality","cpuInstructionSets":null,"gpuRequired":["gen9"]},{"name":"DSP Control","description":"An Intel\u00ae FPGA tutorial demonstrating the DSP control feature","url":"https:\/\/github.com\/oneapi-src\/oneAPI-samples\/tree\/master\/DirectProgramming\/C++SYCL_FPGA\/Tutorials\/Features\/dsp_control","languages":[{"cpp":{}}],"targetDevice":["FPGA"],"expertise":"Concepts and Functionality","cpuInstructionSets":null,"gpuRequired":null},{"name":"Dynamic Profiler","description":"An tutorial demonstrating how to use the Intel\u00ae FPGA Dynamic Profiler for Data Parallel C++ (DPC++) to dynamically collect performance data and reveal areas for optimization","url":"https:\/\/github.com\/oneapi-src\/oneAPI-samples\/tree\/master\/DirectProgramming\/C++SYCL_FPGA\/Tutorials\/Tools\/dynamic_profiler","languages":[{"cpp":{}}],"targetDevice":["FPGA"],"expertise":"Getting Started","cpuInstructionSets":null,"gpuRequired":null},{"name":"Enable Auto-Mixed Precision for Transfer Learning with TensorFlow","description":"This tutorial guides you through the process of enabling auto-mixed precision to use low-precision datatypes, like bfloat16, for transfer learning with TensorFlow*","url":"https:\/\/github.com\/oneapi-src\/oneAPI-samples\/tree\/master\/AI-and-Analytics\/Features-and-Functionality\/IntelTensorFlow_Enabling_Auto_Mixed_Precision_for_TransferLearning","languages":[{"python":{}}],"targetDevice":["CPU"],"expertise":"Code Optimization","cpuInstructionSets":null,"gpuRequired":null},{"name":"Explicit Data Movement","description":"An Intel\u00ae FPGA tutorial demonstrating an alternative coding style, explicit USM, in which all data movement is controlled explicitly by the author","url":"https:\/\/github.com\/oneapi-src\/oneAPI-samples\/tree\/master\/DirectProgramming\/C++SYCL_FPGA\/Tutorials\/DesignPatterns\/explicit_data_movement","languages":[{"cpp":{}}],"targetDevice":["FPGA"],"expertise":"Code Optimization","cpuInstructionSets":null,"gpuRequired":null},{"name":"Fast Recompile","description":"An Intel\u00ae FPGA tutorial demonstrating how to separate the compilation of host and device code to save development time","url":"https:\/\/github.com\/oneapi-src\/oneAPI-samples\/tree\/master\/DirectProgramming\/C++SYCL_FPGA\/Tutorials\/GettingStarted\/fast_recompile","languages":[{"cpp":{}}],"targetDevice":["FPGA"],"expertise":"Getting Started","cpuInstructionSets":null,"gpuRequired":null},{"name":"Fine-tuning Text Classification Model with Intel\u00ae Neural Compressor (INC)","description":"This sample demonstrates how to fine-tune text model for emotion classification task using Intel\u00ae Neural Compressor Quantization Aware Training (QAT).","url":"https:\/\/github.com\/oneapi-src\/oneAPI-samples\/tree\/master\/AI-and-Analytics\/Features-and-Functionality\/INC_QuantizationAwareTraining_TextClassification","languages":[{"python":{}}],"targetDevice":["CPU"],"expertise":"Getting Started","cpuInstructionSets":null,"gpuRequired":null},{"name":"Folder Options DPCT","description":"Multi-folder project that illustrates migration of a CUDA project that has files located in multiple folders in a directory tree. Uses the `--in-root` and `--out-root` options to tell the Intel\u00ae DPC++ Compatibility Tool where to locate source code to be migrated","url":"https:\/\/github.com\/oneapi-src\/oneAPI-samples\/tree\/master\/Tools\/Migration\/folder-options-dpct","languages":[{"cpp":{}}],"targetDevice":["CPU"],"expertise":"Concepts and Functionality","cpuInstructionSets":null,"gpuRequired":null},{"name":"Fourier Correlation","description":"Compute Fourier correlation with oneAPI","url":"https:\/\/github.com\/oneapi-src\/oneAPI-samples\/tree\/master\/Libraries\/oneMKL\/fourier_correlation","languages":[{"cpp":{"properties":{"projectOptions":[{"projectType":"makefile"}]}}}],"targetDevice":["CPU","GPU"],"expertise":"Concepts and Functionality","cpuInstructionSets":null,"gpuRequired":null},{"name":"FPGA Compile","description":"Intel\u00ae FPGA tutorial introducing how to SYCL for Intel\u00ae FPGA","url":"https:\/\/github.com\/oneapi-src\/oneAPI-samples\/tree\/master\/DirectProgramming\/C++SYCL_FPGA\/Tutorials\/GettingStarted\/fpga_compile","languages":[{"cpp":{}}],"targetDevice":["FPGA"],"expertise":"Getting Started","cpuInstructionSets":null,"gpuRequired":null},{"name":"FPGA Reg","description":"An Intel\u00ae FPGA advanced tutorial demonstrating how to apply the SYCL extension ext::intel::fpga_reg","url":"https:\/\/github.com\/oneapi-src\/oneAPI-samples\/tree\/master\/DirectProgramming\/C++SYCL_FPGA\/Tutorials\/Features\/fpga_reg","languages":[{"cpp":{}}],"targetDevice":["FPGA"],"expertise":"Concepts and Functionality","cpuInstructionSets":null,"gpuRequired":null},{"name":"FPGA Template","description":"This project serves as a template for Intel\u00ae oneAPI DPC++\/C++ designs targeting FPGAs. ","url":"https:\/\/github.com\/oneapi-src\/oneAPI-samples\/tree\/master\/DirectProgramming\/C++SYCL_FPGA\/Tutorials\/GettingStarted\/fpga_template","languages":[{"cpp":{}}],"targetDevice":["FPGA"],"expertise":"Getting Started","cpuInstructionSets":null,"gpuRequired":null},{"name":"Gamma Correction","description":"Gamma Correction - a nonlinear operation used to encode and decode the luminance of each image pixel","url":"https:\/\/github.com\/oneapi-src\/oneAPI-samples\/tree\/master\/Libraries\/oneDPL\/gamma-correction","languages":[{"cpp":{}}],"targetDevice":["CPU","GPU"],"expertise":"Concepts and Functionality","cpuInstructionSets":null,"gpuRequired":null},{"name":"Getting Started","description":"Basic Intel\u00ae oneDNN programming model for both Intel\u00ae CPU and GPU","url":"https:\/\/github.com\/oneapi-src\/oneAPI-samples\/tree\/master\/Libraries\/oneDNN\/getting_started","languages":[{"cpp":{}}],"targetDevice":["CPU","GPU"],"expertise":"Getting Started","cpuInstructionSets":null,"gpuRequired":null},{"name":"Getting Started with Intel\u00ae Neural Compressor for Quantization","description":"This sample is a getting started guide for Intel\u00ae Neural Compressor to do INT8 quantization on a Huggingface BERT model. This allows us to achieve performance boosts on Intel hardware.","url":"https:\/\/github.com\/oneapi-src\/oneAPI-samples\/tree\/master\/AI-and-Analytics\/Getting-Started-Samples\/INC-Quantization-Sample-for-PyTorch","languages":[{"python":{}}],"targetDevice":["CPU"],"expertise":"Code Optimization","cpuInstructionSets":null,"gpuRequired":null},{"name":"Guided iso3dfd GPU optimization","description":"Step-by-step GPU optimization guide with Intel Advisor and ISO3DFD sample","url":"https:\/\/github.com\/oneapi-src\/oneAPI-samples\/tree\/master\/DirectProgramming\/C++SYCL\/StructuredGrids\/guided_iso3dfd_GPUOptimization","languages":[{"cpp":{}}],"targetDevice":["CPU","GPU"],"expertise":"Code Optimization","cpuInstructionSets":null,"gpuRequired":null},{"name":"Guided Matrix Multiplication Bad Buffers","description":"The Guided Matrix Multiplication Bad Buffers sample demonstrates how to use the Intel\u00ae oneAPI Base Toolkit (Base Kit) and several tools found in it to triage incorrect use of the SYCL language.","url":"https:\/\/github.com\/oneapi-src\/oneAPI-samples\/tree\/master\/Tools\/ApplicationDebugger\/guided_matrix_mult_BadBuffers","languages":[{"cpp":{}}],"targetDevice":["CPU","GPU"],"expertise":"Tutorial","cpuInstructionSets":null,"gpuRequired":null},{"name":"Guided Matrix Multiplication Illegal SLM Size","description":"The Guided Matrix Multiplication Illegal SLM Size sample demonstrates a guided approach to debugging incorrect usage when reserving more memory for a work-group than there is space, also called Shared Local Memory (SLM). It uses the Intel\u00ae oneAPI Base Toolkit (Base Kit) and several tools included in the Base Kit.","url":"https:\/\/github.com\/oneapi-src\/oneAPI-samples\/tree\/master\/Tools\/ApplicationDebugger\/guided_matrix_mult_SLMSize","languages":[{"cpp":{}}],"targetDevice":["CPU","GPU"],"expertise":"Tutorial","cpuInstructionSets":null,"gpuRequired":null},{"name":"guided_oddEvenMergeSort_SYCLMigration","description":"This is the preferred algorithm of choice for sorting batches of short-sized to mid-sized (key, value) array pairs.","url":"https:\/\/github.com\/oneapi-src\/oneAPI-samples\/tree\/master\/DirectProgramming\/C++SYCL\/GraphTraversal\/guided_odd_even_merge_sort_SYCLMigration","languages":[{"cpp":{}}],"targetDevice":["CPU","GPU"],"expertise":"Code Optimization","cpuInstructionSets":null,"gpuRequired":null},{"name":"GZIP","description":"Reference design demonstrating high-performance GZIP compression on Intel\u00ae FPGA","url":"https:\/\/github.com\/oneapi-src\/oneAPI-samples\/tree\/master\/DirectProgramming\/C++SYCL_FPGA\/ReferenceDesigns\/gzip","languages":[{"cpp":{}}],"targetDevice":["FPGA"],"expertise":"Reference Designs and End to End","cpuInstructionSets":null,"gpuRequired":null},{"name":"Hidden Markov Models","description":"Hidden Markov Models using Data Parallel C++","url":"https:\/\/github.com\/oneapi-src\/oneAPI-samples\/tree\/master\/DirectProgramming\/C++SYCL\/GraphTraversal\/hidden-markov-models","languages":[{"cpp":{}}],"targetDevice":["CPU","GPU"],"expertise":"Concepts and Functionality","cpuInstructionSets":null,"gpuRequired":["gen11"]},{"name":"Histogram","description":"This sample demonstrates Histogram using Dpstd APIs","url":"https:\/\/github.com\/oneapi-src\/oneAPI-samples\/tree\/master\/DirectProgramming\/C++SYCL\/ParallelPatterns\/histogram","languages":[{"cpp":{}}],"targetDevice":["CPU","GPU"],"expertise":"Getting Started","cpuInstructionSets":null,"gpuRequired":null},{"name":"Host Pipes","description":"An Intel\u00ae FPGA tutorial demonstrating the usage of host pipes","url":"https:\/\/github.com\/oneapi-src\/oneAPI-samples\/tree\/master\/DirectProgramming\/C++SYCL_FPGA\/Tutorials\/Features\/experimental\/hostpipes","languages":[{"cpp":{}}],"targetDevice":["FPGA"],"expertise":"Concepts and Functionality","cpuInstructionSets":null,"gpuRequired":null},{"name":"Host-Device Streaming using USM","description":"An FPGA tutorial demonstrating how to stream data between the host and device with low latency and high throughput","url":"https:\/\/github.com\/oneapi-src\/oneAPI-samples\/tree\/master\/DirectProgramming\/C++SYCL_FPGA\/Tutorials\/DesignPatterns\/simple_host_streaming","languages":[{"cpp":{}}],"targetDevice":["FPGA"],"expertise":"Code Optimization","cpuInstructionSets":null,"gpuRequired":null},{"name":"Intel PyTorch GPU Inference Optimization with AMP","description":"This sample illustrates how to use AMP BFLOAT16 in PyTorch on Intel dGPU","url":"https:\/\/github.com\/oneapi-src\/oneAPI-samples\/tree\/master\/AI-and-Analytics\/Features-and-Functionality\/IntelPyTorch_GPU_InferenceOptimization_with_AMP","languages":[{"python":{}}],"targetDevice":["GPU"],"expertise":"Code Optimization","cpuInstructionSets":null,"gpuRequired":null},{"name":"Intel(R) AI Analytics Toolkit (AI Kit) Container Getting Started","description":"This sample illustrates how to utilize the oneAPI AI Kit container.","url":"https:\/\/github.com\/oneapi-src\/oneAPI-samples\/tree\/master\/AI-and-Analytics\/Getting-Started-Samples\/IntelAIKitContainer_GettingStarted","languages":[{"python":{}}],"targetDevice":["CPU"],"expertise":"Tutorial","cpuInstructionSets":null,"gpuRequired":null},{"name":"Intel(R) Extension for Scikit-learn: SVC for Adult dataset","description":"Use Intel(R) Extension for Scikit-learn to accelerate the training and prediction with SVC algorithm on Adult dataset. Compare the performance of SVC algorithm optimized through Intel(R) Extension for Scikit-learn against original Scikit-learn.","url":"https:\/\/github.com\/oneapi-src\/oneAPI-samples\/tree\/master\/AI-and-Analytics\/Features-and-Functionality\/Intel_Extension_For_SKLearn_Performance_SVC_Adult","languages":[{"python":{}}],"targetDevice":["CPU"],"expertise":"Concepts and Functionality","cpuInstructionSets":null,"gpuRequired":null},{"name":"Intel\u00ae Distribution for Python* Distributed K- Means Model","description":"This sample code illustrates how to train and predict with a distributed K-Means model with the Intel\u00ae Distribution of Python using the Python API package Daal4py powered by Intel\u00ae oneDAL","url":"https:\/\/github.com\/oneapi-src\/oneAPI-samples\/tree\/master\/AI-and-Analytics\/Features-and-Functionality\/IntelPython_daal4py_DistributedKMeans","languages":[{"python":{}}],"targetDevice":["CPU"],"expertise":"Concepts and Functionality","cpuInstructionSets":null,"gpuRequired":null},{"name":"Intel\u00ae Distribution for Python* Distributed Linear regression","description":"This sample code illustrates how to train and predict with a Distributed Linear Regression model with the Intel\u00ae Distribution of Python using the Python API package Daal4py powered by Intel\u00ae oneDAL","url":"https:\/\/github.com\/oneapi-src\/oneAPI-samples\/tree\/master\/AI-and-Analytics\/Features-and-Functionality\/IntelPython_daal4py_DistributedLinearRegression","languages":[{"python":{}}],"targetDevice":["CPU"],"expertise":"Concepts and Functionality","cpuInstructionSets":null,"gpuRequired":null},{"name":"Intel\u00ae Distribution for Python* programming language Daal4py Getting Started","description":"This sample illustrates how to do Batch Linear Regression using the Python API package Daal4py powered by Intel\u00ae oneDAL","url":"https:\/\/github.com\/oneapi-src\/oneAPI-samples\/tree\/master\/AI-and-Analytics\/Getting-Started-Samples\/IntelPython_daal4py_GettingStarted","languages":[{"python":{}}],"targetDevice":["CPU"],"expertise":"Getting Started","cpuInstructionSets":null,"gpuRequired":null},{"name":"Intel\u00ae Distribution of Modin* Getting Started","description":"This sample illustrates how to use Modin accelerated Pandas functions and notes the performance gain when compared to standard Pandas functions","url":"https:\/\/github.com\/oneapi-src\/oneAPI-samples\/tree\/master\/AI-and-Analytics\/Getting-Started-Samples\/IntelModin_GettingStarted","languages":[{"python":{}}],"targetDevice":["CPU"],"expertise":"Getting Started","cpuInstructionSets":null,"gpuRequired":null},{"name":"Intel\u00ae Extension for PyTorch* Getting Started","description":"This sample illustrates how to train a PyTorch model and run inference with Intel\u00ae Extension for PyTorch*","url":"https:\/\/github.com\/oneapi-src\/oneAPI-samples\/tree\/master\/AI-and-Analytics\/Getting-Started-Samples\/Intel_Extension_For_PyTorch_GettingStarted","languages":[{"python":{}}],"targetDevice":["CPU","GPU"],"expertise":"Getting Started","cpuInstructionSets":null,"gpuRequired":["ats-m","pvc"]},{"name":"Intel\u00ae Extension for PyTorch* Training Optimizations for Bfloat16","description":"This sample illustrates how to train a PyTorch model using Advanced Matrix Extensions Bfloat16","url":"https:\/\/github.com\/oneapi-src\/oneAPI-samples\/tree\/master\/AI-and-Analytics\/Features-and-Functionality\/IntelPyTorch_TrainingOptimizations_AMX_BF16","languages":[{"python":{}}],"targetDevice":["CPU"],"expertise":"Code Optimization","cpuInstructionSets":["AVX512","AMX"],"gpuRequired":null},{"name":"Intel\u00ae Extension for Scikit-learn* Getting started","description":"This sample illustrates how to do Image classification using SVM classifier from Python API package SKlearnex with the use of Intel\u00ae oneAPI Data Analytics Library (oneDAL).","url":"https:\/\/github.com\/oneapi-src\/oneAPI-samples\/tree\/master\/AI-and-Analytics\/Getting-Started-Samples\/Intel_Extension_For_SKLearn_GettingStarted","languages":[{"python":{}}],"targetDevice":["CPU"],"expertise":"Getting Started","cpuInstructionSets":null,"gpuRequired":null},{"name":"Intel\u00ae Extension for TensorFlow* BF16 Inference","description":"This sample illustrates how to inference a TensorFlow model using Advanced Matrix Extensions Bfloat16","url":"https:\/\/github.com\/oneapi-src\/oneAPI-samples\/tree\/master\/AI-and-Analytics\/Features-and-Functionality\/IntelTensorFlow_AMX_BF16_Inference","languages":[{"python":{}}],"targetDevice":["CPU"],"expertise":"Code Optimization","cpuInstructionSets":["AVX512","AMX"],"gpuRequired":null},{"name":"Intel\u00ae Extension for TensorFlow* Getting Started","description":"This code example illustrates how to run FP32 and Int8 inference on Resnet50 with TensorFlow using Intel\u00ae Model Zoo","url":"https:\/\/github.com\/oneapi-src\/oneAPI-samples\/tree\/master\/AI-and-Analytics\/Getting-Started-Samples\/Intel_Extension_For_TensorFlow_GettingStarted","languages":[{"python":{}}],"targetDevice":["CPU"],"expertise":"Code Optimization","cpuInstructionSets":null,"gpuRequired":null},{"name":"Intel\u00ae Modin Vs. Pandas Performance","description":"This sample code illustrates how Intel\u00ae Modin accelerates the performance of Pandas for computational operations on a dataframe.","url":"https:\/\/github.com\/oneapi-src\/oneAPI-samples\/tree\/master\/AI-and-Analytics\/Getting-Started-Samples\/IntelModin_Vs_Pandas","languages":[{"python":{}}],"targetDevice":["CPU"],"expertise":"Concepts and Functionality","cpuInstructionSets":null,"gpuRequired":null},{"name":"Intel\u00ae Neural Compressor Accelerate Inference with Intel\u00ae Optimization for TensorFlow*","description":"This sample illustrates how to run Intel\u00ae Neural Compressor to quantize the FP32 model trained by Keras on Tensorflow to INT8 model to speed up the inference.","url":"https:\/\/github.com\/oneapi-src\/oneAPI-samples\/tree\/master\/AI-and-Analytics\/Getting-Started-Samples\/INC-Sample-for-Tensorflow","languages":[{"python":{}}],"targetDevice":["CPU"],"expertise":"Getting Started","cpuInstructionSets":null,"gpuRequired":null},{"name":"Intel\u00ae Optimization for TensorFlow* Getting Started","description":"This sample illustrates how to train a TensorFlow model and run inference with oneMKL and oneDNN.","url":"https:\/\/github.com\/oneapi-src\/oneAPI-samples\/tree\/master\/AI-and-Analytics\/Getting-Started-Samples\/IntelTensorFlow_GettingStarted","languages":[{"python":{}}],"targetDevice":["CPU"],"expertise":"Getting Started","cpuInstructionSets":null,"gpuRequired":null},{"name":"Intel\u00ae Optimization for TensorFlow* pre-trained model for inference","description":"This tutorial will guide you how to optimize a pre-trained model for a better inference performance, and also analyze the model pb files before and after the inference optimizations.","url":"https:\/\/github.com\/oneapi-src\/oneAPI-samples\/tree\/master\/AI-and-Analytics\/Features-and-Functionality\/IntelTensorFlow_InferenceOptimization","languages":[{"python":{}}],"targetDevice":["CPU"],"expertise":"Code Optimization","cpuInstructionSets":null,"gpuRequired":null},{"name":"Intel\u00ae Optimization for XGBoost* Getting Started","description":"The sample illustrates how to setup and train an XGBoost model on datasets for prediction","url":"https:\/\/github.com\/oneapi-src\/oneAPI-samples\/tree\/master\/AI-and-Analytics\/Getting-Started-Samples\/IntelPython_XGBoost_GettingStarted","languages":[{"python":{}}],"targetDevice":["CPU"],"expertise":"Getting Started","cpuInstructionSets":null,"gpuRequired":null},{"name":"Intel\u00ae Python NumPy vs Numba_dpex","description":"This sample shows how to achieve the same accuracy of the k-NN model classification while using numpy, numba and numba_dpex.","url":"https:\/\/github.com\/oneapi-src\/oneAPI-samples\/tree\/master\/AI-and-Analytics\/Features-and-Functionality\/IntelPython_Numpy_Numba_dpex_kNN","languages":[{"python":{}}],"targetDevice":["CPU"],"expertise":"Code Optimization","cpuInstructionSets":null,"gpuRequired":null},{"name":"Intel\u00ae Python XGBoost Daal4py Prediction","description":"This sample code illustrates how to analyze the performance benefit of minimal code changes to port pre-trained XGBoost model to daal4py prediction for much faster prediction","url":"https:\/\/github.com\/oneapi-src\/oneAPI-samples\/tree\/master\/AI-and-Analytics\/Features-and-Functionality\/IntelPython_XGBoost_daal4pyPrediction","languages":[{"python":{}}],"targetDevice":["CPU"],"expertise":"Code Optimization","cpuInstructionSets":null,"gpuRequired":null},{"name":"Intel\u00ae Python XGBoost Performance","description":"This sample code illustrates how to analyze the performance benefit from using Intel training optimizations upstreamed by Intel to latest XGBoost compared to un-optimized XGBoost 0.81 ","url":"https:\/\/github.com\/oneapi-src\/oneAPI-samples\/tree\/master\/AI-and-Analytics\/Features-and-Functionality\/IntelPython_XGBoost_Performance","languages":[{"python":{}}],"targetDevice":["CPU"],"expertise":"Code Optimization","cpuInstructionSets":null,"gpuRequired":null},{"name":"Interactive chat based on DialoGPT model using Intel\u00ae Extension for PyTorch* Quantization","description":"This sample demonstrates how to create interactive chat based on pre-treained DialoGPT model and add the Intel\u00ae Extension for PyTorch* quantization to it.","url":"https:\/\/github.com\/oneapi-src\/oneAPI-samples\/tree\/master\/AI-and-Analytics\/Features-and-Functionality\/IntelPytorch_Interactive_Chat_Quantization","languages":[{"python":{}}],"targetDevice":["CPU"],"expertise":"Getting Started","cpuInstructionSets":null,"gpuRequired":null},{"name":"Intrinsics","description":"Demonstrates the Intrinsic functions of the Intel\u00ae oneAPI C++ Compiler Classic","url":"https:\/\/github.com\/oneapi-src\/oneAPI-samples\/tree\/master\/DirectProgramming\/C++\/CompilerInfrastructure\/Intrinsics","languages":[{"cpp":{}}],"targetDevice":["CPU"],"expertise":"Concepts and Functionality","cpuInstructionSets":null,"gpuRequired":null},{"name":"Introduction to Machine Learning","description":"The Jupyter Notebooks in these samples are intended to give professors and students an accessible but challenging introduction to machine learning. It enumerates and describes many commonly used Scikit-learn* algorithms, which are used daily to address machine learning challenges. It has a secondary benefit of demonstrating how to accelerate commonly used Scikit-learn algorithms for Intel CPUs using Intel Extensions for Scikit-learn* which is part of the Intel\u00ae AI Analytics Toolkit (AI Kit) powered by oneAPI. This workshop is designed to be used on the Intel\u00ae DevCloud and includes details on submitting batch jobs on the DevCloud environment.","url":"https:\/\/github.com\/oneapi-src\/oneAPI-samples\/tree\/master\/AI-and-Analytics\/Jupyter\/Introduction_to_Machine_Learning","languages":[{"python":{}}],"targetDevice":["CPU"],"expertise":"Tutorial","cpuInstructionSets":null,"gpuRequired":null},{"name":"Invocation Interfaces","description":"An Intel\u00ae FPGA tutorial demonstrating the usage of register_map and streaming invocation interfaces","url":"https:\/\/github.com\/oneapi-src\/oneAPI-samples\/tree\/master\/DirectProgramming\/C++SYCL_FPGA\/Tutorials\/Features\/experimental\/invocation_interfaces","languages":[{"cpp":{}}],"targetDevice":["FPGA"],"expertise":"Concepts and Functionality","cpuInstructionSets":null,"gpuRequired":null},{"name":"IO streaming with SYCL IO pipes","description":"An FPGA tutorial describing how to stream data to and from SYCL IO pipes.","url":"https:\/\/github.com\/oneapi-src\/oneAPI-samples\/tree\/master\/DirectProgramming\/C++SYCL_FPGA\/Tutorials\/DesignPatterns\/io_streaming","languages":[{"cpp":{}}],"targetDevice":["FPGA"],"expertise":"Code Optimization","cpuInstructionSets":null,"gpuRequired":null},{"name":"ISO2DFD DPCPP","description":"The ISO2DFD sample illustrates SYCL Basics using 2D Finite Difference Wave Propagation","url":"https:\/\/github.com\/oneapi-src\/oneAPI-samples\/tree\/master\/DirectProgramming\/C++SYCL\/StructuredGrids\/iso2dfd_dpcpp","languages":[{"cpp":{}}],"targetDevice":["CPU","GPU"],"expertise":"Concepts and Functionality","cpuInstructionSets":null,"gpuRequired":["gen11"]},{"name":"ISO3DFD","description":"The ISO3DFD Sample illustrates SYCL using Finite Difference Stencil Kernel for solving 3D Acoustic Isotropic Wave Equation","url":"https:\/\/github.com\/oneapi-src\/oneAPI-samples\/tree\/master\/DirectProgramming\/C++SYCL\/StructuredGrids\/iso3dfd_dpcpp","languages":[{"cpp":{}}],"targetDevice":["CPU"],"expertise":"Concepts and Functionality","cpuInstructionSets":null,"gpuRequired":null},{"name":"ISO3DFD OMP Offload","description":"A Finite Difference Stencil Kernel for solving 3D Acoustic Isotropic Wave Equation using OpenMP* (OMP)","url":"https:\/\/github.com\/oneapi-src\/oneAPI-samples\/tree\/master\/DirectProgramming\/C++\/StructuredGrids\/iso3dfd_omp_offload","languages":[{"cpp":{}}],"targetDevice":["GPU"],"expertise":"Concepts and Functionality","cpuInstructionSets":null,"gpuRequired":null},{"name":"Jacobi","description":"A small SYCL (C++) example which solves a harcoded linear system with Jacobi iteration. The sample includes two versions of the same program: with and without bugs.","url":"https:\/\/github.com\/oneapi-src\/oneAPI-samples\/tree\/master\/Tools\/ApplicationDebugger\/jacobi","languages":[{"cpp":{}}],"targetDevice":["CPU","GPU"],"expertise":"Concepts and Functionality","cpuInstructionSets":null,"gpuRequired":null},{"name":"Jacobi Cuda Graphs Sample","description":"Migration of JacobiCudaGraphs from CUDA to SYCL, demonstrates usage of Taskflow programming model inplace of CUDA Graph API's and optimization of the migrated code","url":"https:\/\/github.com\/oneapi-src\/oneAPI-samples\/tree\/master\/DirectProgramming\/C++SYCL\/DenseLinearAlgebra\/guided_jacobiCudaGraphs_SYCLMigration","languages":[{"cpp":{}}],"targetDevice":["CPU","GPU"],"expertise":"Concepts and Functionality","cpuInstructionSets":null,"gpuRequired":null},{"name":"Jacobi Iterative Solver","description":"Jacobi Iterative Solver provides step by step instructions for CPU, GPU and multiple GPU offload","url":"https:\/\/github.com\/oneapi-src\/oneAPI-samples\/tree\/master\/DirectProgramming\/C++SYCL\/DenseLinearAlgebra\/guided_jacobi_iterative_gpu_optimization","languages":[{"cpp":{}}],"targetDevice":["CPU","GPU"],"expertise":"Code Optimization","cpuInstructionSets":null,"gpuRequired":["gen11"]},{"name":"Kernel Args Restrict","description":"Explain the kernel_args_restrict attribute and its effect on the performance of Intel\u00ae FPGA kernels","url":"https:\/\/github.com\/oneapi-src\/oneAPI-samples\/tree\/master\/DirectProgramming\/C++SYCL_FPGA\/Tutorials\/Features\/kernel_args_restrict","languages":[{"cpp":{}}],"targetDevice":["FPGA"],"expertise":"Concepts and Functionality","cpuInstructionSets":null,"gpuRequired":null},{"name":"Latency Control","description":"An Intel\u00ae FPGA tutorial demonstrating the Latency control feature","url":"https:\/\/github.com\/oneapi-src\/oneAPI-samples\/tree\/master\/DirectProgramming\/C++SYCL_FPGA\/Tutorials\/Features\/experimental\/latency_control","languages":[{"cpp":{}}],"targetDevice":["FPGA"],"expertise":"Concepts and Functionality","cpuInstructionSets":null,"gpuRequired":null},{"name":"Lidar Object Detection using PointPillars","description":"Object detection using a LIDAR point cloud as input. This implementation is based on the paper 'PointPillars: Fast Encoders for Object Detection from Point Clouds'","url":"https:\/\/github.com\/oneapi-src\/oneAPI-samples\/tree\/master\/AI-and-Analytics\/End-to-end-Workloads\/LidarObjectDetection-PointPillars","languages":[{"cpp":{}}],"targetDevice":["CPU","GPU"],"expertise":"Reference Designs and End to End","cpuInstructionSets":null,"gpuRequired":null},{"name":"Loop Coalesce","description":"An Intel\u00ae FPGA tutorial demonstrating the loop_coalesce attribute","url":"https:\/\/github.com\/oneapi-src\/oneAPI-samples\/tree\/master\/DirectProgramming\/C++SYCL_FPGA\/Tutorials\/Features\/loop_coalesce","languages":[{"cpp":{}}],"targetDevice":["FPGA"],"expertise":"Concepts and Functionality","cpuInstructionSets":null,"gpuRequired":null},{"name":"Loop Fusion","description":"An Intel\u00ae FPGA tutorial demonstrating the usage of the loop_fusion attribute","url":"https:\/\/github.com\/oneapi-src\/oneAPI-samples\/tree\/master\/DirectProgramming\/C++SYCL_FPGA\/Tutorials\/Features\/loop_fusion","languages":[{"cpp":{}}],"targetDevice":["FPGA"],"expertise":"Concepts and Functionality","cpuInstructionSets":null,"gpuRequired":null},{"name":"Loop Initiation Interval","description":"An Intel\u00ae FPGA tutorial demonstrating the usage of the initiation_interval attribute","url":"https:\/\/github.com\/oneapi-src\/oneAPI-samples\/tree\/master\/DirectProgramming\/C++SYCL_FPGA\/Tutorials\/Features\/loop_initiation_interval","languages":[{"cpp":{}}],"targetDevice":["FPGA"],"expertise":"Concepts and Functionality","cpuInstructionSets":null,"gpuRequired":null},{"name":"Loop IVDEP","description":"An Intel\u00ae FPGA tutorial demonstrating the usage of the loop_ivdep attribute","url":"https:\/\/github.com\/oneapi-src\/oneAPI-samples\/tree\/master\/DirectProgramming\/C++SYCL_FPGA\/Tutorials\/Features\/loop_ivdep","languages":[{"cpp":{}}],"targetDevice":["FPGA"],"expertise":"Concepts and Functionality","cpuInstructionSets":null,"gpuRequired":null},{"name":"Loop Unroll","description":"Demonstrates the use of loop unrolling as a simple optimization technique to speed up compute and increase memory access throughput.","url":"https:\/\/github.com\/oneapi-src\/oneAPI-samples\/tree\/master\/DirectProgramming\/C++SYCL_FPGA\/Tutorials\/Features\/loop_unroll","languages":[{"cpp":{}}],"targetDevice":["CPU","GPU"],"expertise":"Getting Started","cpuInstructionSets":null,"gpuRequired":null},{"name":"Loop Unroll","description":"An Intel\u00ae FPGA tutorial design demonstrating the loop_unroll attribute","url":"https:\/\/github.com\/oneapi-src\/oneAPI-samples\/tree\/master\/DirectProgramming\/C++SYCL_FPGA\/Tutorials\/Features\/loop_unroll","languages":[{"cpp":{}}],"targetDevice":["FPGA"],"expertise":"Concepts and Functionality","cpuInstructionSets":null,"gpuRequired":null},{"name":"LSU Control","description":"An Intel\u00ae FPGA tutorial demonstrating how to configure the load-store units (LSU) in a SYCL program using the LSU controls extension","url":"https:\/\/github.com\/oneapi-src\/oneAPI-samples\/tree\/master\/DirectProgramming\/C++SYCL_FPGA\/Tutorials\/Features\/lsu_control","languages":[{"cpp":{}}],"targetDevice":["FPGA"],"expertise":"Concepts and Functionality","cpuInstructionSets":null,"gpuRequired":null},{"name":"Mandelbrot","description":"The Mandelbrot Set - a fractal\u00a0example in\u00a0mathematics","url":"https:\/\/github.com\/oneapi-src\/oneAPI-samples\/tree\/master\/DirectProgramming\/C++SYCL\/CombinationalLogic\/mandelbrot","languages":[{"cpp":{}}],"targetDevice":["CPU","GPU"],"expertise":"Getting Started","cpuInstructionSets":null,"gpuRequired":null},{"name":"Mandelbrot OMP","description":"Calculates the Mandelbrot Set and outputs a BMP image representation using OpenMP* (OMP)","url":"https:\/\/github.com\/oneapi-src\/oneAPI-samples\/tree\/master\/DirectProgramming\/C++\/CombinationalLogic\/MandelbrotOMP","languages":[{"cpp":{}}],"targetDevice":["CPU","GPU"],"expertise":"Getting Started","cpuInstructionSets":null,"gpuRequired":null},{"name":"matmul","description":"Reference design demonstrating high-performance general matrix multiplication on an Intel\u00ae FPGA","url":"https:\/\/github.com\/oneapi-src\/oneAPI-samples\/tree\/master\/DirectProgramming\/C++SYCL_FPGA\/ReferenceDesigns\/matmul","languages":[{"cpp":{}}],"targetDevice":["FPGA"],"expertise":"Reference Designs and End to End","cpuInstructionSets":null,"gpuRequired":null},{"name":"Matrix Multiplication cuBLAS Migrated","description":"This sample shows the migration of a more complex matrix multiplication sample from cuBLAS to SYCL.","url":"https:\/\/github.com\/oneapi-src\/oneAPI-samples\/tree\/master\/DirectProgramming\/C++SYCL\/DenseLinearAlgebra\/guided_matrix_mul_SYCLMigration","languages":[{"cpp":{}}],"targetDevice":["CPU","GPU"],"expertise":"Code Optimization","cpuInstructionSets":null,"gpuRequired":null},{"name":"Matrix Multiply","description":"Demonstrates how compiler auto-vectorization can improve the performance of a program. The optimization report option is used to identify potential points of performance improvement.","url":"https:\/\/github.com\/oneapi-src\/oneAPI-samples\/tree\/master\/DirectProgramming\/C++\/CompilerInfrastructure\/guided_matmul_opt_report","languages":[{"cpp":{}}],"targetDevice":["CPU"],"expertise":"Tutorial","cpuInstructionSets":null,"gpuRequired":null},{"name":"Matrix Multiply","description":"This sample Multiplies two large Matrices in parallel using SYCL and OpenMP* (OMP)","url":"https:\/\/github.com\/oneapi-src\/oneAPI-samples\/tree\/master\/DirectProgramming\/C++\/CompilerInfrastructure\/guided_matmul_opt_report","languages":[{"cpp":{"properties":{"projectOptions":[{"projectType":"makefile"}]}}}],"targetDevice":["CPU","GPU"],"expertise":"Getting Started","cpuInstructionSets":null,"gpuRequired":null},{"name":"Matrix Multiply Advisor","description":"Simple program that shows how to improve the Intel&reg; oneAPI Data Parallel C++ (DPC++) Matrix Multiplication program using Intel&reg; VTune&trade; Profiler and Intel&reg; Advisor","url":"https:\/\/github.com\/oneapi-src\/oneAPI-samples\/tree\/master\/Tools\/Advisor\/matrix_multiply_advisor","languages":[{"cpp":{}}],"targetDevice":["CPU","GPU"],"expertise":"Getting Started","cpuInstructionSets":null,"gpuRequired":null},{"name":"Matrix Multiply Fortran","description":"Demonstrates how to use OpenMP* directives with Fortran to offload computations to an Intel GPU.","url":"https:\/\/github.com\/oneapi-src\/oneAPI-samples\/tree\/master\/DirectProgramming\/Fortran\/guided_matrix_mul_OpenMP","languages":[{"fortran":{}}],"targetDevice":["CPU","GPU"],"expertise":"Tutorial","cpuInstructionSets":null,"gpuRequired":["pvc"]},{"name":"Matrix Multiply MKL","description":"Accelerate Matrix Multiplication with Intel\u00ae oneMKL","url":"https:\/\/github.com\/oneapi-src\/oneAPI-samples\/tree\/master\/Libraries\/oneMKL\/matrix_mul_mkl","languages":[{"cpp":{"properties":{"projectOptions":[{"projectType":"makefile"}]}}}],"targetDevice":["CPU","GPU"],"expertise":"Concepts and Functionality","cpuInstructionSets":null,"gpuRequired":null},{"name":"Matrix Multiply VTune\u2122 Profiler","description":"Simple program that shows how to improve the Data Parallel C++ (DPC++) Matrix Multiplication program using Intel&reg; VTune&trade; Profiler and Intel&reg; Advisor","url":"https:\/\/github.com\/oneapi-src\/oneAPI-samples\/tree\/master\/Tools\/VTuneProfiler\/matrix_multiply_vtune","languages":[{"cpp":{}}],"targetDevice":["CPU","GPU"],"expertise":"Getting Started","cpuInstructionSets":null,"gpuRequired":null},{"name":"Matrix Multiply VTune\u2122 Profiler - C","description":"Simple program that shows how to improve the C language (CPU only) Matrix Multiplication program using Intel&reg; VTune&trade; Profiler and Intel&reg; Advisor","url":"https:\/\/github.com\/oneapi-src\/oneAPI-samples\/tree\/master\/Tools\/VTuneProfiler\/matrix_multiply_c","languages":[{"c":{}}],"targetDevice":["CPU"],"expertise":"Getting Started","cpuInstructionSets":null,"gpuRequired":null},{"name":"Max Interleaving","description":"An Intel\u00ae FPGA tutorial demonstrating the usage of the loop max_interleaving attribute","url":"https:\/\/github.com\/oneapi-src\/oneAPI-samples\/tree\/master\/DirectProgramming\/C++SYCL_FPGA\/Tutorials\/Features\/max_interleaving","languages":[{"cpp":{}}],"targetDevice":["FPGA"],"expertise":"Concepts and Functionality","cpuInstructionSets":null,"gpuRequired":null},{"name":"Maxloc Reductions in oneAPI","description":"Perform maxloc reductions with oneAPI","url":"https:\/\/github.com\/oneapi-src\/oneAPI-samples\/tree\/master\/Libraries\/oneDPL\/maxloc_reductions","languages":[{"cpp":{"properties":{"projectOptions":[{"projectType":"makefile"}]}}}],"targetDevice":["CPU","GPU"],"expertise":"Concepts and Functionality","cpuInstructionSets":null,"gpuRequired":null},{"name":"Memory Attributes","description":"An Intel\u00ae FPGA tutorial demonstrating the use of on-chip memory attributes to control memory structures in a SYCL program","url":"https:\/\/github.com\/oneapi-src\/oneAPI-samples\/tree\/master\/DirectProgramming\/C++SYCL_FPGA\/Tutorials\/Features\/memory_attributes","languages":[{"cpp":{}}],"targetDevice":["FPGA"],"expertise":"Concepts and Functionality","cpuInstructionSets":null,"gpuRequired":null},{"name":"Merge Sort","description":"A Reference design demonstrating merge sort on an Intel\u00ae FPGA","url":"https:\/\/github.com\/oneapi-src\/oneAPI-samples\/tree\/master\/DirectProgramming\/C++SYCL_FPGA\/ReferenceDesigns\/merge_sort","languages":[{"cpp":{}}],"targetDevice":["FPGA"],"expertise":"Reference Designs and End to End","cpuInstructionSets":null,"gpuRequired":null},{"name":"Merge SPMV","description":"The Sparse Matrix Vector sample provides a parallel implementation of a Merge based Sparse Matrix and Vector Multiplication Algorithm using SYCL","url":"https:\/\/github.com\/oneapi-src\/oneAPI-samples\/tree\/master\/DirectProgramming\/C++SYCL\/SparseLinearAlgebra\/merge-spmv","languages":[{"cpp":{}}],"targetDevice":["CPU","GPU"],"expertise":"Concepts and Functionality","cpuInstructionSets":null,"gpuRequired":null},{"name":"MergeSort OMP","description":"Classic OpenMP* (OMP) Mergesort algorithm","url":"https:\/\/github.com\/oneapi-src\/oneAPI-samples\/tree\/master\/DirectProgramming\/C++\/GraphTraversal\/MergesortOMP","languages":[{"cpp":{}}],"targetDevice":["CPU"],"expertise":"Concepts and Functionality","cpuInstructionSets":null,"gpuRequired":null},{"name":"Model Zoo for Intel\u00ae Architecture Inference With FP32 Int8","description":"This code example illustrates how to run FP32 and Int8 inference on Resnet50 with TensorFlow using Intel\u00ae Model Zoo","url":"https:\/\/github.com\/oneapi-src\/oneAPI-samples\/tree\/master\/AI-and-Analytics\/Features-and-Functionality\/IntelTensorFlow_ModelZoo_Inference_with_FP32_Int8","languages":[{"python":{}}],"targetDevice":["CPU"],"expertise":"Code Optimization","cpuInstructionSets":null,"gpuRequired":null},{"name":"Monte Carlo European Opt","description":"Monte Carlo Simulation of European Options pricing with Intel\u00ae oneMKL random number generators","url":"https:\/\/github.com\/oneapi-src\/oneAPI-samples\/tree\/master\/Libraries\/oneMKL\/monte_carlo_european_opt","languages":[{"cpp":{"properties":{"projectOptions":[{"projectType":"makefile"}]}}}],"targetDevice":["CPU","GPU"],"expertise":"Concepts and Functionality","cpuInstructionSets":null,"gpuRequired":["gen11"]},{"name":"Monte Carlo Pi","description":"Estimating Pi with Intel\u00ae oneMKL random number generators","url":"https:\/\/github.com\/oneapi-src\/oneAPI-samples\/tree\/master\/DirectProgramming\/C++SYCL\/MapReduce\/MonteCarloPi","languages":[{"cpp":{"properties":{"projectOptions":[{"projectType":"makefile"}]}}}],"targetDevice":["CPU","GPU"],"expertise":"Concepts and Functionality","cpuInstructionSets":null,"gpuRequired":null},{"name":"Monte Carlo Pi","description":"Monte Carlo procedure for estimating Pi","url":"https:\/\/github.com\/oneapi-src\/oneAPI-samples\/tree\/master\/DirectProgramming\/C++SYCL\/MapReduce\/MonteCarloPi","languages":[{"cpp":{}}],"targetDevice":["CPU","GPU"],"expertise":"Concepts and Functionality","cpuInstructionSets":null,"gpuRequired":["gen11"]},{"name":"MontecarloMultiGPU","description":"Evaluates fair call price for a given set of European Options using the MonteCarlo approach","url":"https:\/\/github.com\/oneapi-src\/oneAPI-samples\/tree\/master\/DirectProgramming\/C++SYCL\/MapReduce\/guided_MonteCarloMultiGPU_SYCLMigration","languages":[{"cpp":{}}],"targetDevice":["CPU","GPU"],"expertise":"Code Optimization","cpuInstructionSets":null,"gpuRequired":null},{"name":"MVDR Beamforming","description":"A reference design demonstrating a high-performance streaming MVDR beamformer","url":"https:\/\/github.com\/oneapi-src\/oneAPI-samples\/tree\/master\/DirectProgramming\/C++SYCL_FPGA\/ReferenceDesigns\/mvdr_beamforming","languages":[{"cpp":{}}],"targetDevice":["FPGA"],"expertise":"Reference Designs and End to End","cpuInstructionSets":null,"gpuRequired":null},{"name":"N-Body","description":"An N-Body simulation is a simulation of a dynamical system of particles, usually under the influence of physical forces, such as gravity. This N-Body sample code is implemented using SYCL for CPU and GPU","url":"https:\/\/github.com\/oneapi-src\/oneAPI-samples\/tree\/master\/DirectProgramming\/C++SYCL\/N-BodyMethods\/Nbody","languages":[{"cpp":{}}],"targetDevice":["CPU","GPU"],"expertise":"Concepts and Functionality","cpuInstructionSets":null,"gpuRequired":null},{"name":"N-Way Buffering","description":"Intel\u00ae FPGA tutorial design to demonstrate overlapping kernel execution with buffer transfers and multi-threaded host-processing to improve system performance","url":"https:\/\/github.com\/oneapi-src\/oneAPI-samples\/tree\/master\/DirectProgramming\/C++SYCL_FPGA\/Tutorials\/DesignPatterns\/n_way_buffering","languages":[{"cpp":{}}],"targetDevice":["FPGA"],"expertise":"Code Optimization","cpuInstructionSets":null,"gpuRequired":null},{"name":"Numba Data Parallel Python* Essentials Training","description":"Numba Data Parallel Python* Essentials Tutorials using Jupyter Notebooks","url":"https:\/\/github.com\/oneapi-src\/oneAPI-samples\/tree\/master\/AI-and-Analytics\/Jupyter\/Numba_dpex_Essentials_training","languages":[{"python":{}}],"targetDevice":["CPU","GPU"],"expertise":"Tutorial","cpuInstructionSets":null,"gpuRequired":null},{"name":"On-Chip Memory Cache","description":"Intel\u00ae FPGA tutorial demonstrating the caching of on-chip memory to reduce loop initiation interval","url":"https:\/\/github.com\/oneapi-src\/oneAPI-samples\/tree\/master\/DirectProgramming\/C++SYCL_FPGA\/Tutorials\/DesignPatterns\/onchip_memory_cache","languages":[{"cpp":{}}],"targetDevice":["FPGA"],"expertise":"Code Optimization","cpuInstructionSets":null,"gpuRequired":null},{"name":"oneCCL Getting Started","description":"Basic Intel\u00ae oneCCL programming model for both Intel\u00ae CPU and GPU","url":"https:\/\/github.com\/oneapi-src\/oneAPI-samples\/tree\/master\/Libraries\/oneCCL\/oneCCL_Getting_Started","languages":[{"cpp":{}}],"targetDevice":["CPU","GPU"],"expertise":"Getting Started","cpuInstructionSets":null,"gpuRequired":null},{"name":"OpenMP Offload","description":"Demonstration of the new OpenMP offload features supported by the Intel(r) oneAPI DPC++\/C++ Compiler","url":"https:\/\/github.com\/oneapi-src\/oneAPI-samples\/tree\/master\/DirectProgramming\/C++\/CompilerInfrastructure\/OpenMP_Offload_Features","languages":[{"cpp":{}}],"targetDevice":["CPU","GPU"],"expertise":"Concepts and Functionality","cpuInstructionSets":null,"gpuRequired":null},{"name":"OpenMP Offload C++ Tutorials","description":"C++ OpenMP Offload Basics using Jupyter Notebooks","url":"https:\/\/github.com\/oneapi-src\/oneAPI-samples\/tree\/master\/DirectProgramming\/C++\/Jupyter\/OpenMP-offload-training","languages":[{"cpp":{}}],"targetDevice":["CPU","GPU"],"expertise":"Tutorial","cpuInstructionSets":null,"gpuRequired":null},{"name":"OpenMP Offload Fortran Tutorials","description":"Fortran OpenMP Offload Basics using Jupyter Notebooks","url":"https:\/\/github.com\/oneapi-src\/oneAPI-samples\/tree\/master\/DirectProgramming\/Fortran\/Jupyter\/OpenMP-offload-training","languages":[{"fortran":{}}],"targetDevice":["CPU","GPU"],"expertise":"Tutorial","cpuInstructionSets":null,"gpuRequired":null},{"name":"OpenMP* Primes","description":"Fortran Tutorial - Using OpenMP* (OMP)","url":"https:\/\/github.com\/oneapi-src\/oneAPI-samples\/tree\/master\/DirectProgramming\/Fortran\/CombinationalLogic\/openmp-primes","languages":[{"fortran":{}}],"targetDevice":["CPU"],"expertise":"Concepts and Functionality","cpuInstructionSets":null,"gpuRequired":null},{"name":"OpenMP* Reduction","description":"This sample models OpenMP* (OMP) Reduction in different ways showing capability of Intel\u00ae oneAPI","url":"https:\/\/github.com\/oneapi-src\/oneAPI-samples\/tree\/master\/DirectProgramming\/C++\/ParallelPatterns\/openmp_reduction","languages":[{"cpp":{}}],"targetDevice":["CPU","GPU"],"expertise":"Code Optimization","cpuInstructionSets":null,"gpuRequired":null},{"name":"Optimization Targets","description":"An Intel\u00ae FPGA tutorial demonstrating setting optimization targets","url":"https:\/\/github.com\/oneapi-src\/oneAPI-samples\/tree\/master\/DirectProgramming\/C++SYCL_FPGA\/Tutorials\/Features\/optimization_targets","languages":[{"cpp":{}}],"targetDevice":["FPGA"],"expertise":"Concepts and Functionality","cpuInstructionSets":null,"gpuRequired":null},{"name":"Optimize Inner Loop","description":"An Intel\u00ae FPGA tutorial design demonstrating how to optimize the throughput of inner loops with low trip counts","url":"https:\/\/github.com\/oneapi-src\/oneAPI-samples\/tree\/master\/DirectProgramming\/C++SYCL_FPGA\/Tutorials\/DesignPatterns\/optimize_inner_loop","languages":[{"cpp":{}}],"targetDevice":["FPGA"],"expertise":"Code Optimization","cpuInstructionSets":null,"gpuRequired":null},{"name":"Optimize Integral","description":"Fortran Sample - Simple Compiler Optimizations","url":"https:\/\/github.com\/oneapi-src\/oneAPI-samples\/tree\/master\/DirectProgramming\/Fortran\/DenseLinearAlgebra\/optimize-integral","languages":[{"fortran":{}}],"targetDevice":["CPU"],"expertise":"Concepts and Functionality","cpuInstructionSets":null,"gpuRequired":null},{"name":"Optimize PyTorch Models using Intel\u00ae Extension for PyTorch* (IPEX)","description":"Applying IPEX Optimizations to a PyTorch workload in a step-by-step manner to gain performance boost.","url":"https:\/\/github.com\/oneapi-src\/oneAPI-samples\/tree\/master\/AI-and-Analytics\/Features-and-Functionality\/IntelPyTorch_Extensions_Inference_Optimization","languages":[{"python":{}}],"targetDevice":["CPU"],"expertise":"Code Optimization","cpuInstructionSets":null,"gpuRequired":null},{"name":"Optimize PyTorch Models using Intel\u00ae Extension for PyTorch* (IPEX) Quantization","description":"Applying IPEX Quantization Optimizations to a PyTorch workload in a step-by-step manner to gain performance boost in inference.","url":"https:\/\/github.com\/oneapi-src\/oneAPI-samples\/tree\/master\/AI-and-Analytics\/Features-and-Functionality\/IntelPytorch_Quantization","languages":[{"python":{}}],"targetDevice":["CPU"],"expertise":"Concepts and Functionality","cpuInstructionSets":null,"gpuRequired":null},{"name":"Particle Diffusion","description":"The Particle Diffusion code sample illustrates SYCL using a simple (non-optimized) implementation of a Monte Carlo Simulation of the Diffusion of Water Molecules in Tissue","url":"https:\/\/github.com\/oneapi-src\/oneAPI-samples\/tree\/master\/DirectProgramming\/C++SYCL\/StructuredGrids\/particle-diffusion","languages":[{"cpp":{}}],"targetDevice":["CPU","GPU"],"expertise":"Concepts and Functionality","cpuInstructionSets":null,"gpuRequired":["gen11"]},{"name":"PCA","description":"Reference design implementing the Principle Component Analysis (PCA) of matrices on Intel\u00ae FPGAs","url":"https:\/\/github.com\/oneapi-src\/oneAPI-samples\/tree\/master\/DirectProgramming\/C++SYCL_FPGA\/ReferenceDesigns\/pca","languages":[{"cpp":{}}],"targetDevice":["FPGA"],"expertise":"Reference Designs and End to End","cpuInstructionSets":null,"gpuRequired":null},{"name":"Pipe Array","description":"An Intel\u00ae FPGA tutorial showcasing a design pattern to enables the creation of arrays of pipes","url":"https:\/\/github.com\/oneapi-src\/oneAPI-samples\/tree\/master\/DirectProgramming\/C++SYCL_FPGA\/Tutorials\/DesignPatterns\/pipe_array","languages":[{"cpp":{}}],"targetDevice":["FPGA"],"expertise":"Code Optimization","cpuInstructionSets":null,"gpuRequired":null},{"name":"pipelined kernels","description":"An Intel\u00ae FPGA tutorial demonstrating the usage of kernel pipelining","url":"https:\/\/github.com\/oneapi-src\/oneAPI-samples\/tree\/master\/DirectProgramming\/C++SYCL_FPGA\/Tutorials\/Features\/experimental\/pipelined_kernels","languages":[{"cpp":{}}],"targetDevice":["FPGA"],"expertise":"Concepts and Functionality","cpuInstructionSets":null,"gpuRequired":null},{"name":"Pipes","description":"How to use Pipes to transfer data between kernels on an Intel\u00ae FPGA","url":"https:\/\/github.com\/oneapi-src\/oneAPI-samples\/tree\/master\/DirectProgramming\/C++SYCL_FPGA\/Tutorials\/Features\/pipes","languages":[{"cpp":{}}],"targetDevice":["FPGA"],"expertise":"Concepts and Functionality","cpuInstructionSets":null,"gpuRequired":null},{"name":"Platform Designer - Intel\u00ae Arria\u00ae 10 SX SoC Developer Kit","description":"An Intel\u00ae FPGA tutorial demonstrating how to export a reusable IP component to Intel\u00ae Quartus\u00ae Prime Pro and Platform Designer.","url":"https:\/\/github.com\/oneapi-src\/oneAPI-samples\/tree\/master\/DirectProgramming\/C++SYCL_FPGA\/Tutorials\/Tools\/experimental\/platform_designer","languages":[{"cpp":{}}],"targetDevice":["FPGA"],"expertise":"Getting Started","cpuInstructionSets":null,"gpuRequired":null},{"name":"Predictive Modeling with XGBoost* and the Intel\u00ae AI Analytics Toolkit (AI Kit)","description":"Predictive Modeling using Decision Trees, Bagging, and XGBoost using Intel\u00ae AI Analytics Toolkit and Jupyter Notebooks","url":"https:\/\/github.com\/oneapi-src\/oneAPI-samples\/tree\/master\/AI-and-Analytics\/Jupyter\/Predictive_Modeling_Training","languages":[{"python":{}}],"targetDevice":["CPU"],"expertise":"Concepts and Functionality","cpuInstructionSets":null,"gpuRequired":null},{"name":"Prefix Sum","description":"Compute Prefix Sum using SYCL","url":"https:\/\/github.com\/oneapi-src\/oneAPI-samples\/tree\/master\/DirectProgramming\/C++SYCL\/ParallelPatterns\/PrefixSum","languages":[{"cpp":{}}],"targetDevice":["CPU","GPU"],"expertise":"Getting Started","cpuInstructionSets":null,"gpuRequired":null},{"name":"Printf","description":"This FPGA tutorial explains how to use the printf() to print in a SYCL FPGA program","url":"https:\/\/github.com\/oneapi-src\/oneAPI-samples\/tree\/master\/DirectProgramming\/C++SYCL_FPGA\/Tutorials\/Features\/printf","languages":[{"cpp":{}}],"targetDevice":["FPGA"],"expertise":"Concepts and Functionality","cpuInstructionSets":null,"gpuRequired":null},{"name":"private_copies","description":"An Intel\u00ae FPGA tutorial demonstrating how to use the private_copies attribute to trade off the resource use and the throughput of a SYCL FPGA program","url":"https:\/\/github.com\/oneapi-src\/oneAPI-samples\/tree\/master\/DirectProgramming\/C++SYCL_FPGA\/Tutorials\/Features\/private_copies","languages":[{"cpp":{}}],"targetDevice":["FPGA"],"expertise":"Concepts and Functionality","cpuInstructionSets":null,"gpuRequired":null},{"name":"PyTorch Inference Optimizations with Advanced Matrix Extensions Bfloat16 and Integer8","description":"This sample illustrates how to do inference with a PyTorch model using Advanced Matrix Extensions Bfloat16 and Integer8","url":"https:\/\/github.com\/oneapi-src\/oneAPI-samples\/tree\/master\/AI-and-Analytics\/Features-and-Functionality\/IntelPyTorch_InferenceOptimizations_AMX_BF16_INT8","languages":[{"python":{}}],"targetDevice":["CPU"],"expertise":"Code Optimization","cpuInstructionSets":["AVX512","AMX"],"gpuRequired":null},{"name":"QRD","description":"Reference design demonstrating high-performance QR Decomposition (QRD) of real and complex matrices on a Intel\u00ae FPGA","url":"https:\/\/github.com\/oneapi-src\/oneAPI-samples\/tree\/master\/DirectProgramming\/C++SYCL_FPGA\/ReferenceDesigns\/qrd","languages":[{"cpp":{}}],"targetDevice":["FPGA"],"expertise":"Reference Designs and End to End","cpuInstructionSets":null,"gpuRequired":null},{"name":"QRI","description":"Reference design demonstrating high-performance QR-based matrix inversion (QRI) of real and complex matrices on a Intel\u00ae FPGA","url":"https:\/\/github.com\/oneapi-src\/oneAPI-samples\/tree\/master\/DirectProgramming\/C++SYCL_FPGA\/ReferenceDesigns\/qri","languages":[{"cpp":{}}],"targetDevice":["FPGA"],"expertise":"Reference Designs and End to End","cpuInstructionSets":null,"gpuRequired":null},{"name":"quasirandomGenerator","description":"Implements Niederreiter Quasirandom Sequence Generator and Inverse Cumulative Normal Distribution functions for the generation of Standard Normal Distributions.","url":"https:\/\/github.com\/oneapi-src\/oneAPI-samples\/tree\/master\/DirectProgramming\/C++SYCL\/MapReduce\/guided_quasirandomGenerator_SYCLMigration","languages":[{"cpp":{}}],"targetDevice":["CPU","GPU"],"expertise":"Code Optimization","cpuInstructionSets":null,"gpuRequired":null},{"name":"Random Sampling Without Replacement","description":"Multiple simple random sampling without replacement with Intel\u00ae oneMKL random number generators","url":"https:\/\/github.com\/oneapi-src\/oneAPI-samples\/tree\/master\/Libraries\/oneMKL\/random_sampling_without_replacement","languages":[{"cpp":{"properties":{"projectOptions":[{"projectType":"makefile"}]}}}],"targetDevice":["CPU","GPU"],"expertise":"Concepts and Functionality","cpuInstructionSets":null,"gpuRequired":null},{"name":"Read-Only Cache","description":"An Intel\u00ae FPGA tutorial demonstrating how to use the read-only cache feature to boost the throughput of a SYCL FPGA program","url":"https:\/\/github.com\/oneapi-src\/oneAPI-samples\/tree\/master\/DirectProgramming\/C++SYCL_FPGA\/Tutorials\/Features\/read_only_cache","languages":[{"cpp":{}}],"targetDevice":["FPGA"],"expertise":"Concepts and Functionality","cpuInstructionSets":null,"gpuRequired":null},{"name":"Remove Loop Carried Dependency","description":"An Intel\u00ae FPGA tutorial design demonstrating performance optimization by removing loop carried dependencies","url":"https:\/\/github.com\/oneapi-src\/oneAPI-samples\/tree\/master\/DirectProgramming\/C++SYCL_FPGA\/Tutorials\/DesignPatterns\/loop_carried_dependency","languages":[{"cpp":{}}],"targetDevice":["FPGA"],"expertise":"Code Optimization","cpuInstructionSets":null,"gpuRequired":null},{"name":"Rodinia NW DPCT","description":"Migrate a CUDA project using the Intel\u00ae DPCT intercept-build feature to create a compilation database. The compilation database provides compilation options, settings, macro definitions and include paths that the Intel\u00ae DPC++ Compatibility Tool (DPCT) will use during migration of the project","url":"https:\/\/github.com\/oneapi-src\/oneAPI-samples\/tree\/master\/Tools\/Migration\/rodinia-nw-dpct","languages":[{"cpp":{}}],"targetDevice":["CPU"],"expertise":"Concepts and Functionality","cpuInstructionSets":null,"gpuRequired":null},{"name":"Run distributed deep learning workloads with Intel\u00ae Optimization for Horovod","description":"This sample demonstrates how to run multi-card inference and training on Intel GPUs using Intel Optimization for Horovod and TensorFlow","url":"https:\/\/github.com\/oneapi-src\/oneAPI-samples\/tree\/master\/AI-and-Analytics\/Features-and-Functionality\/IntelTensorFlow_Horovod_Distributed_Deep_Learning","languages":[{"python":{}}],"targetDevice":["GPU"],"expertise":"Getting Started","cpuInstructionSets":null,"gpuRequired":null},{"name":"Scheduler Target FMAX","description":"Explain the scheduler_target_fmax_mhz attribute and its effect on the performance of Intel\u00ae FPGA kernels","url":"https:\/\/github.com\/oneapi-src\/oneAPI-samples\/tree\/master\/DirectProgramming\/C++SYCL_FPGA\/Tutorials\/Features\/scheduler_target_fmax","languages":[{"cpp":{}}],"targetDevice":["FPGA"],"expertise":"Concepts and Functionality","cpuInstructionSets":null,"gpuRequired":null},{"name":"Sepia Filter","description":"A program that converts an image to Sepia Tone","url":"https:\/\/github.com\/oneapi-src\/oneAPI-samples\/tree\/master\/DirectProgramming\/C++SYCL\/CombinationalLogic\/sepia-filter","languages":[{"cpp":{}}],"targetDevice":["CPU","GPU"],"expertise":"Concepts and Functionality","cpuInstructionSets":null,"gpuRequired":null},{"name":"Shannonization","description":"An Intel\u00ae FPGA tutorial design that demonstrates an optimization for removing computation from the critical path and improves Fmax\/II","url":"https:\/\/github.com\/oneapi-src\/oneAPI-samples\/tree\/master\/DirectProgramming\/C++SYCL_FPGA\/Tutorials\/DesignPatterns\/shannonization","languages":[{"cpp":{}}],"targetDevice":["FPGA"],"expertise":"Code Optimization","cpuInstructionSets":null,"gpuRequired":null},{"name":"Simple Add","description":"This simple sample adds two large vectors in parallel and provides a \u2018Hello World!\u2019 like sample to ensure your environment is setup correctly using C++ with SYCL","url":"https:\/\/github.com\/oneapi-src\/oneAPI-samples\/tree\/master\/DirectProgramming\/C++SYCL\/DenseLinearAlgebra\/simple-add","languages":[{"cpp":{"properties":{"projectOptions":[{"projectType":"makefile"}]}}}],"targetDevice":["CPU","GPU","FPGA"],"expertise":"Getting Started","cpuInstructionSets":null,"gpuRequired":null},{"name":"Simple Cuda Graphs Sample","description":"Migration of simpleCudaGraphs from CUDA to SYCL, demonstrates usage of Taskflow programming model inplace of CUDA Graph API's","url":"https:\/\/github.com\/oneapi-src\/oneAPI-samples\/tree\/master\/DirectProgramming\/C++SYCL\/DenseLinearAlgebra\/guided_simpleCudaGraphs_SYCLMigration","languages":[{"cpp":{}}],"targetDevice":["CPU","GPU"],"expertise":"Concept and Functionality","cpuInstructionSets":null,"gpuRequired":null},{"name":"Sparse Conjugate Gradient","description":"Solve Sparse linear systems with the Conjugate Gradient method using Intel\u00ae oneMKL sparse BLAS","url":"https:\/\/github.com\/oneapi-src\/oneAPI-samples\/tree\/master\/Libraries\/oneMKL\/sparse_conjugate_gradient","languages":[{"cpp":{"properties":{"projectOptions":[{"projectType":"makefile"}]}}}],"targetDevice":["CPU","GPU"],"expertise":"Concepts and Functionality","cpuInstructionSets":null,"gpuRequired":null},{"name":"Speculated Iterations","description":"An Intel\u00ae FPGA tutorial demonstrating the speculated_iterations attribute","url":"https:\/\/github.com\/oneapi-src\/oneAPI-samples\/tree\/master\/DirectProgramming\/C++SYCL_FPGA\/Tutorials\/Features\/speculated_iterations","languages":[{"cpp":{}}],"targetDevice":["FPGA"],"expertise":"Concepts and Functionality","cpuInstructionSets":null,"gpuRequired":null},{"name":"Stable Sort By Key","description":"This sample models Stable Sort By Key during the sorting of 2 sequences (keys and values) only keys are compared but both keys and values are swapped","url":"https:\/\/github.com\/oneapi-src\/oneAPI-samples\/tree\/master\/Libraries\/oneDPL\/stable_sort_by_key","languages":[{"cpp":{}}],"targetDevice":["CPU","GPU"],"expertise":"Concepts and Functionality","cpuInstructionSets":null,"gpuRequired":null},{"name":"Stall Enable","description":"An Intel\u00ae FPGA tutorial demonstrating the use_stall_enable_clusters attribute","url":"https:\/\/github.com\/oneapi-src\/oneAPI-samples\/tree\/master\/DirectProgramming\/C++SYCL_FPGA\/Tutorials\/Features\/stall_enable","languages":[{"cpp":{}}],"targetDevice":["FPGA"],"expertise":"Concepts and Functionality","cpuInstructionSets":null,"gpuRequired":null},{"name":"STREAM","description":"The STREAM is a program that measures memory transfer rates in MB\/s for simple computational kernels coded in C","url":"https:\/\/github.com\/oneapi-src\/oneAPI-samples\/tree\/master\/Tools\/Benchmarks\/STREAM","languages":[{"cpp":{}}],"targetDevice":["CPU","GPU"],"expertise":"Concepts and Functionality","cpuInstructionSets":null,"gpuRequired":["gen11"]},{"name":"Student's T-test","description":"Performing Student's T-test with Intel\u00ae oneMKL Vector Statistics functionality","url":"https:\/\/github.com\/oneapi-src\/oneAPI-samples\/tree\/master\/Libraries\/oneMKL\/student_t_test","languages":[{"cpp":{"properties":{"projectOptions":[{"projectType":"makefile"}]}}}],"targetDevice":["CPU","GPU"],"expertise":"Getting Started","cpuInstructionSets":null,"gpuRequired":null},{"name":"SYCL Essentials Tutorials","description":"SYCL Essentials Tutorials using Jupyter Notebooks","url":"https:\/\/github.com\/oneapi-src\/oneAPI-samples\/tree\/master\/DirectProgramming\/C++SYCL\/Jupyter\/oneapi-essentials-training","languages":[{"cpp":{"properties":{"projectOptions":[{"projectType":"makefile"}]}}}],"targetDevice":["CPU","GPU"],"expertise":"Tutorial","cpuInstructionSets":null,"gpuRequired":null},{"name":"SYCL OpenCL Interoperability Samples","description":"Samples showing SYCL and OpenCL Interoperability","url":"https:\/\/github.com\/oneapi-src\/oneAPI-samples\/tree\/master\/DirectProgramming\/C++SYCL\/OpenCLInterop","languages":[{"cpp":{"properties":{"projectOptions":[{"projectType":"makefile"}]}}}],"targetDevice":["CPU","GPU"],"expertise":"Concepts and Functionality","cpuInstructionSets":null,"gpuRequired":null},{"name":"SYCL Performance Portability","description":"SYCL Performance Portability using Jupyter Notebooks","url":"https:\/\/github.com\/oneapi-src\/oneAPI-samples\/tree\/master\/DirectProgramming\/C++SYCL\/Jupyter\/sycl-performance-portability-training","languages":[{"cpp":{"properties":{"projectOptions":[{"projectType":"makefile"}]}}}],"targetDevice":["CPU","GPU"],"expertise":"Tutorial","cpuInstructionSets":null,"gpuRequired":null},{"name":"System Profiling","description":"An Intel\u00ae FPGA tutorial demonstrating how to use the OpenCL* Intercept Layer to improve a design with the double buffering optimization","url":"https:\/\/github.com\/oneapi-src\/oneAPI-samples\/tree\/master\/DirectProgramming\/C++SYCL_FPGA\/Tutorials\/Tools\/system_profiling","languages":[{"cpp":{}}],"targetDevice":["FPGA"],"expertise":"Code Optimization","cpuInstructionSets":null,"gpuRequired":null},{"name":"TBB ASYNC SYCL","description":"This sample illustrates how computational kernel can be split for execution between CPU and GPU using Intel\u00ae oneTBB Flow Graph asynchronous node and functional node. The Flow Graph asynchronous node uses SYCL to implement calculations on GPU while the functional node does CPU part of calculations. This TBB ASYNC SYCL sample code is implemented using C++ and SYCL language for Intel\u00ae CPU and GPU","url":"https:\/\/github.com\/oneapi-src\/oneAPI-samples\/tree\/master\/Libraries\/oneTBB\/tbb-async-sycl","languages":[{"cpp":{}}],"targetDevice":["CPU","GPU"],"expertise":"Code Optimization","cpuInstructionSets":null,"gpuRequired":null},{"name":"TBB Resumable Tasks SYCL","description":"This sample illustrates how computational kernel can be split for execution between CPU and GPU using Intel\u00ae oneTBB Resumable Task and parallel_for. The Intel\u00ae oneTBB resumable task uses SYCL to implement calculations on GPU while the parallel_for algorithm does CPU part of calculations. This TBB Resumable Tasks SYCL sample code is implemented using C++ and SYCL language for Intel\u00ae CPU and GPU","url":"https:\/\/github.com\/oneapi-src\/oneAPI-samples\/tree\/master\/Libraries\/oneTBB\/tbb-resumable-tasks-sycl","languages":[{"cpp":{}}],"targetDevice":["CPU","GPU"],"expertise":"Code Optimization","cpuInstructionSets":null,"gpuRequired":null},{"name":"TBB Task SYCL","description":"This sample illustrates how 2 Intel\u00ae oneTBB tasks can execute similar computational kernels with one task executing SYCL code and another one executing the Intel\u00ae oneTBB code. This TBB Task SYCL sample code is implemented using C++ and SYCL language for Intel\u00ae CPU and GPU","url":"https:\/\/github.com\/oneapi-src\/oneAPI-samples\/tree\/master\/Libraries\/oneTBB\/tbb-task-sycl","languages":[{"cpp":{}}],"targetDevice":["CPU","GPU"],"expertise":"Code Optimization","cpuInstructionSets":null,"gpuRequired":null},{"name":"TensorFlow Training Optimizations with Advanced Matrix Extensions Bfloat16","description":"This sample illustrates how to train a TensorFlow model using Advanced Matrix Extensions Bfloat16","url":"https:\/\/github.com\/oneapi-src\/oneAPI-samples\/tree\/master\/AI-and-Analytics\/Features-and-Functionality\/IntelTensorFlow_AMX_BF16_Training","languages":[{"python":{}}],"targetDevice":["CPU"],"expertise":"Code Optimization","cpuInstructionSets":["AVX512","AMX"],"gpuRequired":null},{"name":"TensorFlow Transformer with Advanced Matrix Extensions bfloat16 Mixed Precision Learning","description":"This sample code demonstrates optimizing a TensorFlow model with Intel\u00ae Advanced Matrix Extensions (Intel\u00ae AMX) using bfloat16 (Brain Floating Point) on Sapphire Rapids","url":"https:\/\/github.com\/oneapi-src\/oneAPI-samples\/tree\/master\/AI-and-Analytics\/Features-and-Functionality\/IntelTensorFlow_Transformer_AMX_bfloat16_MixedPrecision","languages":[{"python":{}}],"targetDevice":["CPU"],"expertise":"Getting Started","cpuInstructionSets":["AVX512","AMX"],"gpuRequired":null},{"name":"Triangular Loop","description":"An Intel\u00ae FPGA tutorial demonstrating an advanced optimization technique for triangular loops","url":"https:\/\/github.com\/oneapi-src\/oneAPI-samples\/tree\/master\/DirectProgramming\/C++SYCL_FPGA\/Tutorials\/DesignPatterns\/triangular_loop","languages":[{"cpp":{}}],"targetDevice":["FPGA"],"expertise":"Code Optimization","cpuInstructionSets":null,"gpuRequired":null},{"name":"Vector Add DPCT","description":"Simple project to illustrate the basic migration of CUDA code. Use this sample to ensure your environment is configured correctly and to understand the basics of migrating existing CUDA projects to Data Parallel C++ (DPC++)","url":"https:\/\/github.com\/oneapi-src\/oneAPI-samples\/tree\/master\/Tools\/Migration\/vector-add-dpct","languages":[{"cpp":{}}],"targetDevice":["CPU"],"expertise":"Getting Started","cpuInstructionSets":null,"gpuRequired":null},{"name":"Vectorize VecMatMult","description":"Fortran Tutorial - Using Auto Vectorization","url":"https:\/\/github.com\/oneapi-src\/oneAPI-samples\/tree\/master\/DirectProgramming\/Fortran\/DenseLinearAlgebra\/vectorize-vecmatmult","languages":[{"fortran":{}}],"targetDevice":["CPU"],"expertise":"Concepts and Functionality","cpuInstructionSets":null,"gpuRequired":null},{"name":"Zero Copy Data Transfer","description":"An Intel\u00ae FPGA tutorial demonstrating zero-copy host memory using the SYCL restricted Unified Shared Memory (USM) model","url":"https:\/\/github.com\/oneapi-src\/oneAPI-samples\/tree\/master\/DirectProgramming\/C++SYCL_FPGA\/Tutorials\/DesignPatterns\/zero_copy_data_transfer","languages":[{"cpp":{}}],"targetDevice":["FPGA"],"expertise":"Code Optimization","cpuInstructionSets":null,"gpuRequired":null}]